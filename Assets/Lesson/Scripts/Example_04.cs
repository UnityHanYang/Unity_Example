//#define EXAMPLE_TYPE_REFERENCE
//#define EXAMPLE_TYPE_VALUE
#define EXAMPLE_TYPE_NULLABLE
// 매크로는 using문 위에다가 써야한다, 아래다가 쓰면 오류

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#region 즐거운 세계 C#
/*
 2024.05.13 수업내용

▶ C# 언어의 문법을 숙지해야 하는 이유

- 유니티에서 기본적으로 스크릷트는 C#을 채용한다.
ㄴ 이는 엔진의 활용성 + 최적화를 높이기 위해 C#의 이해도를 요구한다.

- C / C++ 스타일로 C# 문법을 모르고 작성하는 것도 가능은 하지만 결국엔 최적화와 효율 문제로 GG

▶ C# 동작 방식 (프로그램)

- C# 프로그램은 CLR 이라는 자바의 가상 머신과 비슷한 프로그램 위에서 구동이 된다.
 ㄴ 이는 C/C++ 언어와 달리 결과물이 컴퓨터가 바로 실행할 수 있는 실행 파일로 생성되지 않는다는 것을 의미한다.


◆ CLR(Common language Runtime)
 ㄴ 마소(마이크로소프트)에서 개발한 가상 머신의 구성 요소라고 할 수 있다. -> 윈도우 전용
 ㄴ 기능은 크게 2가지
    ㄴ 1. 중간 언어를 JIT 컴파일러를 통해 기계어로 변환 가능
    ㄴ 2. 가비지 컬렉션을 통한 메모리 관리 (동적)

◆ 가상 머신
 ㄴ 가상의 컴퓨팅을 하는 방식
 ㄴ 메인 자원(본체)에 대한 가상화를 시켜서 새로운 OS를 만드는 기법

- C#은 CLR이라는 중간 과정을 거쳐서 다른 언어를 사용할 수 있게 지원을 한다.
- CLR은 CIL 코드를 읽어들여 OS가 이해할 수 있는  Native Code로 변환시켜주는 역할을 수행한다.
ㄴ 이 때 서로 다른 언어들이 만나는 지점 "IL" 이라고 하는 곳이며 이 언어로 쓰여진 코드를 CLR이
다시 자신이 실행한 플랫폼에 맞춰서 컴파일 하는 구조를 가지고 있다.

CLR == CIL

◆ CTL (공통 중간 언어)
 ㄴ 닷넷 프레임워크에서 실행되는 언어
 ㄴ 닷넷 프레임워크 언어로 개발된 프로그램 코드는 컴파일 시 바이너리형태로 CIL이라고 불리는
    파일로 작성이 된다.

흰색 배경: 닷넷 프레임워크

◆ .NET Framework
 ㄴ Windows 프로그램 개발 및 실행 환경
 ㄴ 네트워크 작업을 하거나 인터페이스 등의 작업을 할 때 캡슐화하여 코딩의 효율을
    올려주는 역할을 한다.
 ㄴ 특정으로는 CLS을 따르는 언어라면 어떠한 언어라도 닷넷 프레임워크에서 실행이 가능하다.
 ㄴ 또한 CLR이라는 가상 기계 위에서 작동을 하기 때문에 플랫폼에 독립적이고 궁극적으로는 코딩을
    하는데 더 편한 환경을 제공하낟. (함수 + API)

◆ CLS
ㄴ


- 결국 C# 언어는 컴파일이 되었을 경우 운영체제에서 바로 실행할 수 있는 네이티브 코드로 변환되는
것이 아니라 CLR에서 인식할 수 있는 CIL이라는 중간 언어를 생성하는 것이다.

- 그리고 CLR 구동중에 CIL 코드를 읽어 들여서 특정 운영체제에 맞는 네이티브 코드로 변환이 된다.
    ㄴ 이러한 방식을 JIT 컴파일 방식이라고 한다.


★ C# 프로그램은 궁극적으로 컴파일 + 인터프리터 방식의 혼합 하이브리드 방식으로 구동이 된다.

◆ JIT

장점
ㄴ 프로그램이 구동 중에 즉시 네이티브 코드를 생성하기 때문에 특정 운영체제에 맞는 최적화
코드를 만들어 내는 것이 가능

단점
ㄴ 시간이 걸린다.

▷ CLR의 역할 3가지
ㄴ a. 예외 처리
ㄴ b. 메모리 관리
ㄴ c. 언어 간 호환성 체크한다. (CTS)
 ㄴ 닷넷 프레임워크는 C# 언어만을 위한 프레임워크가 아니기 때문에 C# 언어를 제외한 다른 언어에서도
    닷넷 프레임워크를 이용하는 것이 가능하다.
 ㄴ 이 때 발생하는 언어간 문법적인 차이를 CLR을 통해 통일화 시키는 것이 가능
 ㄴ 통일이 가능한 이유는 내부적으로 CTS 규칙에 따라 데이터 타입을 구현하고 있기 때문에


◆ CTS (Common Type System)
ㄴ 공용 타입 시스템
ㄴ 다스넷 호한 언어가 지켜야 할 타입의 표준 규격으로 닷넷 호환 언어를 만든다면
   CTS 규격을 반드시 지켜야 한다.
ㄴ CTS 규격을 전부 따를 필요 없지만 CTS 규격을 벗어나는 새로운 타입은 지원하지 않는다.


◆  가비지 컬렉션(GC)
ㄴ 1. 스택 메모리 관리
 ㄴ 스택 메모리는 지역적인 특징을 지니고 있기 때문에 시스템에 의해서 관리된다.
  ㄴ 메모리 관리를 위한 추가적인 로직 불필요

ㄴ 2. 힙에 대한 메모리 관리
 C/C++ 언어와는 달리 힙 메모리는 프로그래머에 의해서 직접적으로 관리되지 않는다.
  ㄴ 이를 GC에서 관리한다는 특징이 있다.

- C#언어 같은 경우에는 힙 메모리를 프로그래머가 직접적으로 관리하는 C/C++언어와는 달리
C# 언어의 힙 메모리는 가비지 컬렉션에 의해서 관리가 된다.
ㄴ 이는 메모리 릭에 대한 걱정을 하지 않아도 된다는 얘기


  장점

- 메모리 릭에 대한 걱정을 하지 않아도 된다.

  단점

- C# 언어는 힙 메모리를 할당하는 것이 가능하지만 직접적으로 관리 되지 않기 때문에
불필요한 메모리 공간을 즉시 제거하는 것이 불가능하다.

- 이는 곧 불필요한 메모리가 존재한다는 것을 알고 있다 하더라도 제거할 수 있는 권한자체가 없기 때문에
GC가 구동될 때까지 데이턴은 메모리에 상주한다.


- 또한 GC에 의한 메모리 관리는 많은 부하를 일으키는 원인이 된다.
ㄴ 이는 곧 항상 GC에 상태에 신경을 써서 프로그램 로직을 작성해야 한다는 얘기
 ㄴ 추가로 많은 퍼포먼스가 필요한 게임에서는 최적화에 대한 많은 노력이 필요하다.

소멸자 호출 -> 가비지 컬렉션 수집 가능

- GC는 0 / 1 / 2 -> 전체 가비지 컬렉션

- GC는 기본적으로 단방향(아래쪽)
1세대는 0세대를 관리할 순 있지만 2세대는 관리하지 못한다.
2세대는 0, 1세대 관리 가능
0세대는 아무것도 관리 못함


- 할 수 있다면 참초 관계 형성을 안 하는게 제일 베스트
가비지 컬렉션: 참초 관계가 끊긴 인스턴스 찌꺼기


▶ C# 언어 자료형 특징

- C# 언어는 기본적으로 모든 데이터가 클래스 또는 객체로 인식된다.
ㄴ 말인 즉슨 int, float, double 등의 기본 자료형도 내부적으로 클래스로 표현된다는 것을 의미

- 또한 C# 언어의 자료형의 데이터 타입에 따라서 값 타입과 차몾 타입으로 나뉜다.

- 그리고 데이터의 형식에 따라서 기본 데이터 형식과 복합 데이터 형식으로 구분이 된다.

※ 복합 데이터: 클래스 안에 구조체 + 배열


▷ C# 언어 변수 특징

- C# 언어의 모든 클래스는 오브젝트 클래스를 직 / 간접적으로 상속하는 것이 원칙
 ㄴ 즉, 오브젝트 타입의 변수로 모든 데이터를 보관하는 것이 가능하다.

- 이렇게 변수를 오브젝트 타입으로 다른 데이터 형식의 값을 제어하는 것을
  박싱 / 언박싱 이라고 한다.

- 박싱은 데이터를 보관하는 행위
ㄴ 오브젝트 타입은 기본적으로 참조 형식 => 해당 변수에 값 형식의 변수가 복사될 경우
   내부적으로 힙 메모리를 이용해서 값을 복사한다.
ㄴ 퍼포먼스 저하를 일으키는 요인이 있다.

- 언박싱은 데이터를 읽어들이는 행위
ㄴ 퍼포먼스 저하를 일으키는 요인이 있다.
ㄴ 값을 보관하고 있는 힙 메모리의 값을 읽어 들인다.

- 오브젝트 타입의 변수는 기본적으로 참초 타입이기 때문에 해당 변수에 참조 타입의 값을
보관할 때는 퍼포먼스 저하를 일으키지 않지만 값 형식의 데이터를 보관할 때는 박싱 / 언박싱을
수행하기 때문에 퍼포먼스 저하가 발생한다.

코드 짤 때 고려해야하는 순위:
1. 가비지 컬렉션
2. 박싱, 언박싱

면접 문제: 박싱과 언박싱에 대한 설명과 장단점

C#은 강한형식검사, 약한형식검사가 가지고 있기 때문에
(생성을 시켜두고 자료형을 확정시키는 방식, 자료형을 확정시키기 전엔 오브젝트 형식)

유지보수가 힘들다. 어떻게 돌아가는 지에 대해 미리 정해두기 때문


  C# 값 형식 데이터 타입

※ u가 붙으면 부호가 없다는 의미

- byte (0 ~ 255), sByte(~128 ~ 127)

- int, uint, long, ulong, short, ushort

- float (7), double (15), decimal (29) -> 사용을 권장하지 않음
float과 decimal의 속도차이가 엄청 크다.
ㄴ float이 엄청 빠르다.

- decimal의 단점
느리다.
메모리 사용량이 많다. (decimal은 16byte이기 때문)

- char

- enum

- struct

- Nullable

  C# 찹조 형식 데이터 타입
ㄴ null을 집어넣을 수 있으면 참조 형식
ex) object a = null;

- object
ㄴ 박싱, 언박싱을 쓸 때 값 형식으로 바뀔 수 있다.

- string

- class

- delegate


- 값 / 참조 형식의 차이점은 스택으로 할당이 이뤄지냐 / 힙으로 이뤄지냐의 차이

- 값 타입은 스택에 할당되기 때문에 시스템에 의해서 메모리가 괸라되고 값을 할당할 때
내부적으로 복사가 수행된다. (값 자체의 복사)

- 참조 타입의 자료형은 힙에 할당되기 때문에 GC에 의해서 메모리가 괸리되며 값을 할당할 때
참조 값의 복사가 이뤄진다. (해당 메모리의 주소가 할당된다.)


  Nullable

- 참조 타입의 변수는 null 키워드를 통해서 데이터의 유효성 검사가 가능

- 반면 값 타입의 변수는 null 키워드 사용 자체가 불가
ㄴ 이는 값 자체로 올바른 값인지의 유무를 판단하는 것이 불가능 하다는 얘기

- 그렇기 때문에 Nullable 타입이라는 자료형을 지원하여 값 타입에 유효성 검사를 수행할 수 있다.

 */
#endregion

public class Example_04 : MonoBehaviour
{
    public void Awake()
    {
        // 선택적 컴파일
#if EXAMPLE_TYPE_VALUE
        int nValue = 10;
        float fValue = 3.14f;
        double dValue = 3.14;
        decimal mValue = 3.14m;

        Debug.LogFormat("데이터 출력 : {0}, {1}, {2}, {3}", nValue, fValue, dValue, mValue);


#elif EXAMPLE_TYPE_REFERENCE
        object oValue = 10;
        string oString = "HellFire";

        // $: C# 6.0에서 추가된 기능
        // ㄴ 문자열 보간 (보간된 문자열로 식별)
        // 문자열 보간을 수행하면 2의 배수를 검사한다.
        Debug.Log($"데이터 출력 : {oValue}, {oString}");


#else
        int? nValue = null;
        float? fValue = null;
        // 주소 여부를 사용할 때 ?를 사용해서 null을 할당할 수 있다

        System.Nullable<int> nValueB = 10;

        if(nValue.HasValue)
        {
            Debug.Log("정수형 값이 유효");
        }
        else
        {
            Debug.Log("정수형 값이 유효하지 않음");
        }
        
        if(fValue != null)
        {
            Debug.Log("실수형 값이 유효");
        }
        else
        {
            Debug.Log("실수형 값이 유효하지 않음");
        }

        if(nValueB.HasValue)
        {
            Debug.Log("정수형 값이 유효");
        }
        else
        {
            Debug.Log("정수형 값이 유효하지 않음");
        }
#endif
    }
    
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
